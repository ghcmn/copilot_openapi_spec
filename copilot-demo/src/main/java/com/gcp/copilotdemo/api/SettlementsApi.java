/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech) (5.2.1).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package com.gcp.copilotdemo.api;

import com.gcp.copilotdemo.model.KeyValuePairModel;
import com.gcp.copilotdemo.model.OptionalIdentifiersModel;
import com.gcp.copilotdemo.model.ProblemFormatItemModel;
import com.gcp.copilotdemo.model.SettlementModel;
import io.swagger.annotations.*;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.UUID;
//@javax.annotation.Generated(value = "org.openapitools.codegen.languages.SpringCodegen", date = "2022-11-13T12:08:29.158795400+05:30[Asia/Calcutta]")
@Validated
//@Api(value = "Settlements", description = "the Settlements API")
public interface SettlementsApi {

    default SettlementsApiDelegate getDelegate() {
        return new SettlementsApiDelegate() {};
    }

    /**
     * POST /settlement : adds a new settlement
     * Creates a new settlement. All data fields are validated
     *
     * @param settlementModel settlement to be created (required)
     * @return item created (status code 201)
     *         or Errors occurred (status code 400)
     *         or Forbidden (status code 403)
     *         or an existing duplicate item already exists (status code 409)
     */
    @ApiOperation(value = "adds a new settlement"
            , nickname = "createSettlement"
            , notes = "Creates a new settlement. All data fields are validated"
            , response = SettlementModel.class
            , tags={ "settlements", })
    @ApiResponses(value = { 
        @ApiResponse(code = 201, message = "Settlement created", response = SettlementModel.class),
        @ApiResponse(code = 400, message = "Errors occurred", response = ProblemFormatItemModel.class, responseContainer = "List"),
        @ApiResponse(code = 403, message = "Forbidden"),
        @ApiResponse(code = 409, message = "an existing duplicate item already exists") })
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/settlement",
        produces = { "application/json", "application/problem+json" },
        consumes = { "application/json" }
    )
    default ResponseEntity<SettlementModel> createSettlement(@ApiParam(value = "settlement to be created" ,required=true )  @Valid @RequestBody SettlementModel settlementModel) {
        return getDelegate().createSettlement(settlementModel);
    }


    /**
     * DELETE /settlement/{id} : Delete a settlement record
     * Hard delete of a settlement record. Intended for use only in testing and possibly by applications support staff. Does not check to see if the record has already been aggregated, cancelled or paid. _Caveat emptor..._
     *
     * @param id the unique resource identifier for the settlement (required)
     * @param ifMatch an optimistic lock token respresenting the resource state; usually a hex-encoded MD5 hash value. Obtained from the &#x60;Etag&#x60; response header of a previous GET request for the resource. (required)
     * @return Successful deletion (status code 204)
     *         or Bad Request (status code 400)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     *         or Conflict - the &#x60;If-Match&#x60; value supplied on the request does not match the current &#x60;Etag&#x60; of the record (status code 409)
     */
    @ApiOperation(value = "Delete a settlement record", nickname = "deleteSettlement", notes = "Hard delete of a settlement record. Intended for use only in testing and possibly by applications support staff. Does not check to see if the record has already been aggregated, cancelled or paid. _Caveat emptor..._", tags={ "settlements", })
    @ApiResponses(value = { 
        @ApiResponse(code = 204, message = "Successful deletion"),
        @ApiResponse(code = 400, message = "Bad Request", response = ProblemFormatItemModel.class, responseContainer = "List"),
        @ApiResponse(code = 403, message = "Forbidden"),
        @ApiResponse(code = 404, message = "Not Found"),
        @ApiResponse(code = 409, message = "Conflict - the `If-Match` value supplied on the request does not match the current `Etag` of the record") })
    @RequestMapping(
        method = RequestMethod.DELETE,
        value = "/settlement/{id}",
        produces = { "application/problem+json" }
    )
    default ResponseEntity<Void> deleteSettlement(@ApiParam(value = "the unique resource identifier for the settlement",required=true) @PathVariable("id") UUID id,@ApiParam(value = "an optimistic lock token respresenting the resource state; usually a hex-encoded MD5 hash value. Obtained from the `Etag` response header of a previous GET request for the resource." ,required=true) @RequestHeader(value="If-Match", required=true) String ifMatch) {
        return getDelegate().deleteSettlement(id, ifMatch);
    }


    /**
     * POST /search : Find settlements that meet specific search criteria
     * A flexible search capability. Currently using a POST method due to restrictions in OpenAPI 3.0.0, but this will be deprecated later in favour of a GET with a request body which is allowed at OpenAPI 3.0.3...
     *
     * @param keyValuePairModel Name-value pairs for keyword searches. All search criteria are ANDed together to filter the results (required)
     * @return Success. Note that no matching items (empty array returned) is considered a successful execution. (status code 200)
     *         or Errors occurred (status code 400)
     *         or Forbidden (status code 403)
     */
    @ApiOperation(value = "Find settlements that meet specific search criteria", nickname = "findSettlements", notes = "A flexible search capability. Currently using a POST method due to restrictions in OpenAPI 3.0.0, but this will be deprecated later in favour of a GET with a request body which is allowed at OpenAPI 3.0.3...", response = SettlementModel.class, responseContainer = "List", tags={ "settlements", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success. Note that no matching items (empty array returned) is considered a successful execution.", response = SettlementModel.class, responseContainer = "List"),
        @ApiResponse(code = 400, message = "Errors occurred", response = ProblemFormatItemModel.class, responseContainer = "List"),
        @ApiResponse(code = 403, message = "Forbidden") })
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/search",
        produces = { "application/json", "application/problem+json" },
        consumes = { "application/json" }
    )
    default ResponseEntity<List<SettlementModel>> findSettlements(@ApiParam(value = "Name-value pairs for keyword searches. All search criteria are ANDed together to filter the results" ,required=true )  @Valid @RequestBody List<KeyValuePairModel> keyValuePairModel) {
        return getDelegate().findSettlements(keyValuePairModel);
    }


    /**
     * GET /search : Find settlements that are eligible for aggregation
     * Finds settlements with the same payment method between two dateTimes, that haven&#39;t already been aggregated. Settlements that have **any** of the optional identifiers will not be included in the returned list, as they have previously been aggregated, paid, or cancelled.
     *
     * @param paymentMethod The payment method. All settlements returned will have this payment method. (required)
     * @param from The exclusive lower bound for selection. All settlements selected will have a &#x60;scheduleDate&#x60; greater than this value. (required)
     * @param to The inclusive upper bound for selection. All settlements selected will have a &#x60;scheduleDate&#x60; less than or equal to this value. (required)
     * @return Success. Note that no matching items (empty array returned) is considered a successful execution. (status code 200)
     *         or Errors occurred (status code 400)
     *         or Forbidden (status code 403)
     */
    @ApiOperation(value = "Find settlements that are eligible for aggregation", nickname = "findSettlementsForAggregation", notes = "Finds settlements with the same payment method between two dateTimes, that haven't already been aggregated. Settlements that have **any** of the optional identifiers will not be included in the returned list, as they have previously been aggregated, paid, or cancelled.", response = SettlementModel.class, responseContainer = "List", tags={ "settlements", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "Success. Note that no matching items (empty array returned) is considered a successful execution.", response = SettlementModel.class, responseContainer = "List"),
        @ApiResponse(code = 400, message = "Errors occurred", response = ProblemFormatItemModel.class, responseContainer = "List"),
        @ApiResponse(code = 403, message = "Forbidden") })
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/search",
        produces = { "application/json", "application/problem+json" }
    )
    default ResponseEntity<List<SettlementModel>> findSettlementsForAggregation(@NotNull @ApiParam(value = "The payment method. All settlements returned will have this payment method.", required = true, allowableValues = "STFO, SWIFT, VITESSE, NONE") @Valid @RequestParam(value = "paymentMethod", required = true) String paymentMethod,@NotNull @ApiParam(value = "The exclusive lower bound for selection. All settlements selected will have a `scheduleDate` greater than this value.", required = true) @Valid @RequestParam(value = "from", required = true) @org.springframework.format.annotation.DateTimeFormat(iso = org.springframework.format.annotation.DateTimeFormat.ISO.DATE_TIME) OffsetDateTime from,@NotNull @ApiParam(value = "The inclusive upper bound for selection. All settlements selected will have a `scheduleDate` less than or equal to this value.", required = true) @Valid @RequestParam(value = "to", required = true) @org.springframework.format.annotation.DateTimeFormat(iso = org.springframework.format.annotation.DateTimeFormat.ISO.DATE_TIME) OffsetDateTime to) {
        return getDelegate().findSettlementsForAggregation(paymentMethod, from, to);
    }


    /**
     * GET /settlement/{id} : returns a single settlement by ID
     * Retrieve a settlement by its unique identifier
     *
     * @param id the unique resource identifier for the document (required)
     * @return single settlement (status code 200)
     *         or Forbidden (status code 403)
     *         or Not Found (status code 404)
     *         or Method Not Allowed (status code 405)
     */
    @ApiOperation(value = "returns a single settlement by ID", nickname = "getSettlementById", notes = "Retrieve a settlement by its unique identifier", response = SettlementModel.class, tags={ "settlements", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "single settlement", response = SettlementModel.class),
        @ApiResponse(code = 403, message = "Forbidden"),
        @ApiResponse(code = 404, message = "Not Found"),
        @ApiResponse(code = 405, message = "Method Not Allowed") })
    @RequestMapping(
        method = RequestMethod.GET,
        value = "/settlement/{id}",
        produces = { "application/json" }
    )
    default ResponseEntity<SettlementModel> getSettlementById(@ApiParam(value = "the unique resource identifier for the document",required=true) @PathVariable("id") UUID id) {
        return getDelegate().getSettlementById(id);
    }


    /**
     * POST /settlement/{id} : Mark a settlement as paid, aggregated, or cancelled
     * Allows a &#x60;netSettlementId&#x60;, &#x60;paymentId&#x60;, or &#x60;cancellationId&#x60; to be added to a settlement. Once an ID has been added, it cannot be updated or removed. Settlements that already have either a &#x60;netSettlementId&#x60; or &#x60;paymentId&#x60; cannot be cancelled by giving them a &#x60;cancellationId&#x60;. You can add a &#x60;netSettlementId&#x60; and a &#x60;paymentId&#x60; together in the same call if you wish.
     *
     * @param id the unique resource identifier for the document (required)
     * @param optionalIdentifiersModel identifier(s) to be added (required)
     * @return the attribute(s) requested have been added to the record (status code 200)
     *         or Errors occurred (status code 400)
     *         or Forbidden (status code 403)
     *         or Errors occurred (status code 409)
     */
    @ApiOperation(value = "Mark a settlement as paid, aggregated, or cancelled", nickname = "markSettlement", notes = "Allows a `netSettlementId`, `paymentId`, or `cancellationId` to be added to a settlement. Once an ID has been added, it cannot be updated or removed. Settlements that already have either a `netSettlementId` or `paymentId` cannot be cancelled by giving them a `cancellationId`. You can add a `netSettlementId` and a `paymentId` together in the same call if you wish.", tags={ "settlements", })
    @ApiResponses(value = { 
        @ApiResponse(code = 200, message = "the attribute(s) requested have been added to the record"),
        @ApiResponse(code = 400, message = "Errors occurred", response = ProblemFormatItemModel.class, responseContainer = "List"),
        @ApiResponse(code = 403, message = "Forbidden"),
        @ApiResponse(code = 409, message = "Errors occurred", response = ProblemFormatItemModel.class, responseContainer = "List") })
    @RequestMapping(
        method = RequestMethod.POST,
        value = "/settlement/{id}",
        produces = { "application/problem+json" },
        consumes = { "application/json" }
    )
    default ResponseEntity<Void> markSettlement(@ApiParam(value = "the unique resource identifier for the document",required=true) @PathVariable("id") UUID id,@ApiParam(value = "identifier(s) to be added" ,required=true )  @Valid @RequestBody OptionalIdentifiersModel optionalIdentifiersModel) {
        return getDelegate().markSettlement(id, optionalIdentifiersModel);
    }

}
